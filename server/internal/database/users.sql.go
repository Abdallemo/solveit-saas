// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: users.sql

package database

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const addSolverToTaskBlockList = `-- name: AddSolverToTaskBlockList :one
INSERT INTO blocked_tasks (user_id, task_id, reason)
VALUES ($1, $2, $3) ON CONFLICT (user_id, task_id) DO NOTHING
RETURNING id, user_id, task_id, reason, created_at
`

type AddSolverToTaskBlockListParams struct {
	UserID uuid.UUID   `json:"user_id"`
	TaskID uuid.UUID   `json:"task_id"`
	Reason pgtype.Text `json:"reason"`
}

func (q *Queries) AddSolverToTaskBlockList(ctx context.Context, arg AddSolverToTaskBlockListParams) (BlockedTask, error) {
	row := q.db.QueryRow(ctx, addSolverToTaskBlockList, arg.UserID, arg.TaskID, arg.Reason)
	var i BlockedTask
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TaskID,
		&i.Reason,
		&i.CreatedAt,
	)
	return i, err
}

const getUsers = `-- name: GetUsers :many
SELECT id, name, email, password, role, stripe_customer_id, stripe_account_id, stripe_account_linked, "emailVerified", image, created_at
FROM users
`

func (q *Queries) GetUsers(ctx context.Context) ([]User, error) {
	rows, err := q.db.Query(ctx, getUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Email,
			&i.Password,
			&i.Role,
			&i.StripeCustomerID,
			&i.StripeAccountID,
			&i.StripeAccountLinked,
			&i.EmailVerified,
			&i.Image,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const processSystemNotification = `-- name: ProcessSystemNotification :one
INSERT INTO notifications (
    sender_id,
    receiver_id,
    subject,
    content,
    method,
    read
  )
VALUES ($1, $2, $3, $4, 'SYSTEM', $5)
RETURNING id, sender_id, receiver_id, subject, content, method, read, created_at
`

type ProcessSystemNotificationParams struct {
	SenderID   string      `json:"sender_id"`
	ReceiverID string      `json:"receiver_id"`
	Subject    pgtype.Text `json:"subject"`
	Content    string      `json:"content"`
	Read       bool        `json:"read"`
}

func (q *Queries) ProcessSystemNotification(ctx context.Context, arg ProcessSystemNotificationParams) (Notification, error) {
	row := q.db.QueryRow(ctx, processSystemNotification,
		arg.SenderID,
		arg.ReceiverID,
		arg.Subject,
		arg.Content,
		arg.Read,
	)
	var i Notification
	err := row.Scan(
		&i.ID,
		&i.SenderID,
		&i.ReceiverID,
		&i.Subject,
		&i.Content,
		&i.Method,
		&i.Read,
		&i.CreatedAt,
	)
	return i, err
}
