// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0

package database

import (
	"database/sql/driver"
	"fmt"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

type BookingStatus string

const (
	BookingStatusPENDING  BookingStatus = "PENDING"
	BookingStatusPAID     BookingStatus = "PAID"
	BookingStatusCANCELED BookingStatus = "CANCELED"
)

func (e *BookingStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = BookingStatus(s)
	case string:
		*e = BookingStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for BookingStatus: %T", src)
	}
	return nil
}

type NullBookingStatus struct {
	BookingStatus BookingStatus `json:"booking_status"`
	Valid         bool          `json:"valid"` // Valid is true if BookingStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullBookingStatus) Scan(value interface{}) error {
	if value == nil {
		ns.BookingStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.BookingStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullBookingStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.BookingStatus), nil
}

type FeedbackCategory string

const (
	FeedbackCategoryTASK      FeedbackCategory = "TASK"
	FeedbackCategoryMENTORING FeedbackCategory = "MENTORING"
)

func (e *FeedbackCategory) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = FeedbackCategory(s)
	case string:
		*e = FeedbackCategory(s)
	default:
		return fmt.Errorf("unsupported scan type for FeedbackCategory: %T", src)
	}
	return nil
}

type NullFeedbackCategory struct {
	FeedbackCategory FeedbackCategory `json:"feedback_category"`
	Valid            bool             `json:"valid"` // Valid is true if FeedbackCategory is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullFeedbackCategory) Scan(value interface{}) error {
	if value == nil {
		ns.FeedbackCategory, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.FeedbackCategory.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullFeedbackCategory) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.FeedbackCategory), nil
}

type FileStatus string

const (
	FileStatusPENDING    FileStatus = "PENDING"
	FileStatusPROCESSING FileStatus = "PROCESSING"
	FileStatusCOMPLETED  FileStatus = "COMPLETED"
	FileStatusFAILED     FileStatus = "FAILED"
)

func (e *FileStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = FileStatus(s)
	case string:
		*e = FileStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for FileStatus: %T", src)
	}
	return nil
}

type NullFileStatus struct {
	FileStatus FileStatus `json:"file_status"`
	Valid      bool       `json:"valid"` // Valid is true if FileStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullFileStatus) Scan(value interface{}) error {
	if value == nil {
		ns.FileStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.FileStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullFileStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.FileStatus), nil
}

type Method string

const (
	MethodSYSTEM Method = "SYSTEM"
	MethodEMAIL  Method = "EMAIL"
)

func (e *Method) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = Method(s)
	case string:
		*e = Method(s)
	default:
		return fmt.Errorf("unsupported scan type for Method: %T", src)
	}
	return nil
}

type NullMethod struct {
	Method Method `json:"method"`
	Valid  bool   `json:"valid"` // Valid is true if Method is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullMethod) Scan(value interface{}) error {
	if value == nil {
		ns.Method, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.Method.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullMethod) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.Method), nil
}

type PaymentPorpose string

const (
	PaymentPorposeTaskPayment   PaymentPorpose = "Task Payment"
	PaymentPorposeMentorBooking PaymentPorpose = "Mentor Booking"
)

func (e *PaymentPorpose) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = PaymentPorpose(s)
	case string:
		*e = PaymentPorpose(s)
	default:
		return fmt.Errorf("unsupported scan type for PaymentPorpose: %T", src)
	}
	return nil
}

type NullPaymentPorpose struct {
	PaymentPorpose PaymentPorpose `json:"payment_porpose"`
	Valid          bool           `json:"valid"` // Valid is true if PaymentPorpose is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullPaymentPorpose) Scan(value interface{}) error {
	if value == nil {
		ns.PaymentPorpose, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.PaymentPorpose.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullPaymentPorpose) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.PaymentPorpose), nil
}

type PaymentStatus string

const (
	PaymentStatusHOLD              PaymentStatus = "HOLD"
	PaymentStatusRELEASED          PaymentStatus = "RELEASED"
	PaymentStatusSUCCEEDED         PaymentStatus = "SUCCEEDED"
	PaymentStatusFAILED            PaymentStatus = "FAILED"
	PaymentStatusCANCELED          PaymentStatus = "CANCELED"
	PaymentStatusREFUNDED          PaymentStatus = "REFUNDED"
	PaymentStatusPENDINGUSERACTION PaymentStatus = "PENDING_USER_ACTION"
)

func (e *PaymentStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = PaymentStatus(s)
	case string:
		*e = PaymentStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for PaymentStatus: %T", src)
	}
	return nil
}

type NullPaymentStatus struct {
	PaymentStatus PaymentStatus `json:"payment_status"`
	Valid         bool          `json:"valid"` // Valid is true if PaymentStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullPaymentStatus) Scan(value interface{}) error {
	if value == nil {
		ns.PaymentStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.PaymentStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullPaymentStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.PaymentStatus), nil
}

type RefundStatus string

const (
	RefundStatusPENDING           RefundStatus = "PENDING"
	RefundStatusPROCESSING        RefundStatus = "PROCESSING"
	RefundStatusREFUNDED          RefundStatus = "REFUNDED"
	RefundStatusREJECTED          RefundStatus = "REJECTED"
	RefundStatusFAILED            RefundStatus = "FAILED"
	RefundStatusPENDINGUSERACTION RefundStatus = "PENDING_USER_ACTION"
)

func (e *RefundStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = RefundStatus(s)
	case string:
		*e = RefundStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for RefundStatus: %T", src)
	}
	return nil
}

type NullRefundStatus struct {
	RefundStatus RefundStatus `json:"refund_status"`
	Valid        bool         `json:"valid"` // Valid is true if RefundStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullRefundStatus) Scan(value interface{}) error {
	if value == nil {
		ns.RefundStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.RefundStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullRefundStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.RefundStatus), nil
}

type Role string

const (
	RoleADMIN     Role = "ADMIN"
	RoleMODERATOR Role = "MODERATOR"
	RolePOSTER    Role = "POSTER"
	RoleSOLVER    Role = "SOLVER"
)

func (e *Role) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = Role(s)
	case string:
		*e = Role(s)
	default:
		return fmt.Errorf("unsupported scan type for Role: %T", src)
	}
	return nil
}

type NullRole struct {
	Role  Role `json:"role"`
	Valid bool `json:"valid"` // Valid is true if Role is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullRole) Scan(value interface{}) error {
	if value == nil {
		ns.Role, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.Role.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullRole) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.Role), nil
}

type Status string

const (
	StatusPENDING Status = "PENDING"
	StatusSENT    Status = "SENT"
)

func (e *Status) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = Status(s)
	case string:
		*e = Status(s)
	default:
		return fmt.Errorf("unsupported scan type for Status: %T", src)
	}
	return nil
}

type NullStatus struct {
	Status Status `json:"status"`
	Valid  bool   `json:"valid"` // Valid is true if Status is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullStatus) Scan(value interface{}) error {
	if value == nil {
		ns.Status, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.Status.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.Status), nil
}

type TaskStatus string

const (
	TaskStatusOPEN       TaskStatus = "OPEN"
	TaskStatusASSIGNED   TaskStatus = "ASSIGNED"
	TaskStatusINPROGRESS TaskStatus = "IN_PROGRESS"
	TaskStatusCOMPLETED  TaskStatus = "COMPLETED"
	TaskStatusSUBMITTED  TaskStatus = "SUBMITTED"
)

func (e *TaskStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = TaskStatus(s)
	case string:
		*e = TaskStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for TaskStatus: %T", src)
	}
	return nil
}

type NullTaskStatus struct {
	TaskStatus TaskStatus `json:"task_status"`
	Valid      bool       `json:"valid"` // Valid is true if TaskStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullTaskStatus) Scan(value interface{}) error {
	if value == nil {
		ns.TaskStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.TaskStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullTaskStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.TaskStatus), nil
}

type Tier string

const (
	TierPOSTER Tier = "POSTER"
	TierSOLVER Tier = "SOLVER"
	TierValue2 Tier = "SOLVER++"
)

func (e *Tier) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = Tier(s)
	case string:
		*e = Tier(s)
	default:
		return fmt.Errorf("unsupported scan type for Tier: %T", src)
	}
	return nil
}

type NullTier struct {
	Tier  Tier `json:"tier"`
	Valid bool `json:"valid"` // Valid is true if Tier is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullTier) Scan(value interface{}) error {
	if value == nil {
		ns.Tier, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.Tier.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullTier) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.Tier), nil
}

type Visibility string

const (
	VisibilityPublic  Visibility = "public"
	VisibilityPrivate Visibility = "private"
)

func (e *Visibility) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = Visibility(s)
	case string:
		*e = Visibility(s)
	default:
		return fmt.Errorf("unsupported scan type for Visibility: %T", src)
	}
	return nil
}

type NullVisibility struct {
	Visibility Visibility `json:"visibility"`
	Valid      bool       `json:"valid"` // Valid is true if Visibility is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullVisibility) Scan(value interface{}) error {
	if value == nil {
		ns.Visibility, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.Visibility.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullVisibility) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.Visibility), nil
}

type Account struct {
	ID                    uuid.UUID   `json:"id"`
	UserId                uuid.UUID   `json:"userId"`
	AccountId             string      `json:"accountId"`
	ProviderId            string      `json:"providerId"`
	AccessToken           pgtype.Text `json:"accessToken"`
	RefreshToken          pgtype.Text `json:"refreshToken"`
	AccessTokenExpiresAt  *time.Time  `json:"accessTokenExpiresAt"`
	RefreshTokenExpiresAt *time.Time  `json:"refreshTokenExpiresAt"`
	Scope                 pgtype.Text `json:"scope"`
	IdToken               pgtype.Text `json:"idToken"`
	Password              pgtype.Text `json:"password"`
	CreatedAt             *time.Time  `json:"createdAt"`
	UpdatedAt             *time.Time  `json:"updatedAt"`
	SessionState          pgtype.Text `json:"session_state"`
}

type AiFlag struct {
	ID              uuid.UUID `json:"id"`
	HashedContent   string    `json:"hashed_content"`
	Reason          string    `json:"reason"`
	ConfidenceScore int32     `json:"confidence_score"`
	CreatedAt       time.Time `json:"created_at"`
}

type AiRule struct {
	ID         uuid.UUID `json:"id"`
	Rule       string    `json:"rule"`
	Decription string    `json:"decription"`
	IsActive   bool      `json:"is_active"`
	AdminID    uuid.UUID `json:"admin_id"`
	CreatedAt  time.Time `json:"created_at"`
	UpdatedAt  time.Time `json:"updated_at"`
}

type AiTestSandbox struct {
	ID         uuid.UUID  `json:"id"`
	Content    string     `json:"content"`
	AdminID    uuid.UUID  `json:"admin_id"`
	TestAmount int32      `json:"test_amount"`
	CreatedAt  time.Time  `json:"created_at"`
	UpdatedAt  *time.Time `json:"updated_at"`
}

type BlockedTask struct {
	ID        uuid.UUID   `json:"id"`
	UserID    uuid.UUID   `json:"user_id"`
	TaskID    uuid.UUID   `json:"task_id"`
	Reason    pgtype.Text `json:"reason"`
	CreatedAt time.Time   `json:"created_at"`
}

type Blog struct {
	ID          uuid.UUID `json:"id"`
	Title       string    `json:"title"`
	Url         string    `json:"url"`
	Description string    `json:"description"`
	Content     []byte    `json:"content"`
	Category    string    `json:"category"`
	Author      uuid.UUID `json:"author"`
	PublishedAt time.Time `json:"publishedAt"`
	ReadTime    int32     `json:"readTime"`
}

type Feedback struct {
	ID              uuid.UUID        `json:"id"`
	PosterID        uuid.UUID        `json:"poster_id"`
	SolverID        uuid.UUID        `json:"solver_id"`
	FeedbackType    FeedbackCategory `json:"feedback_type"`
	MentorBookingID *uuid.UUID       `json:"mentor_booking_id"`
	TaskID          *uuid.UUID       `json:"task_id"`
	Rating          int32            `json:"rating"`
	Comment         pgtype.Text      `json:"comment"`
	CreatedAt       time.Time        `json:"created_at"`
}

type GlobalMediaFile struct {
	ID           uuid.UUID  `json:"id"`
	FileName     string     `json:"file_name"`
	FileType     string     `json:"file_type"`
	FileSize     int32      `json:"file_size"`
	FileLocation string     `json:"file_location"`
	FilePath     string     `json:"file_path"`
	UploadedAt   *time.Time `json:"uploaded_at"`
}

type Jwk struct {
	ID         uuid.UUID  `json:"id"`
	PublicKey  string     `json:"publicKey"`
	PrivateKey string     `json:"privateKey"`
	CreatedAt  time.Time  `json:"createdAt"`
	ExpiresAt  *time.Time `json:"expires_at"`
}

type Log struct {
	ID        uuid.UUID   `json:"id"`
	CreatedAt time.Time   `json:"createdAt"`
	Level     string      `json:"level"`
	Message   string      `json:"message"`
	Error     pgtype.Text `json:"error"`
}

type MentorSession struct {
	ID           uuid.UUID   `json:"id"`
	BookingID    uuid.UUID   `json:"booking_id"`
	SessionDate  pgtype.Date `json:"session_date"`
	TimeSlot     []byte      `json:"time_slot"`
	SessionStart time.Time   `json:"session_start"`
	SessionEnd   time.Time   `json:"session_end"`
	CreatedAt    time.Time   `json:"created_at"`
}

type MentorshipBooking struct {
	ID        uuid.UUID     `json:"id"`
	SolverID  uuid.UUID     `json:"solver_id"`
	StudentID uuid.UUID     `json:"student_id"`
	Price     pgtype.Int4   `json:"price"`
	Status    BookingStatus `json:"status"`
	PaymentID *uuid.UUID    `json:"payment_id"`
	Notes     pgtype.Text   `json:"notes"`
	CreatedAt time.Time     `json:"created_at"`
}

type MentorshipChat struct {
	ID        uuid.UUID   `json:"id"`
	SeesionID uuid.UUID   `json:"seesion_id"`
	Message   pgtype.Text `json:"message"`
	SentBy    uuid.UUID   `json:"sent_by"`
	SentTo    uuid.UUID   `json:"sent_to"`
	ReadAt    *time.Time  `json:"read_at"`
	Pending   pgtype.Bool `json:"pending"`
	IsDeleted pgtype.Bool `json:"is_deleted"`
	CreatedAt *time.Time  `json:"created_at"`
}

type MentorshipChatFile struct {
	ID           uuid.UUID  `json:"id"`
	ChatID       uuid.UUID  `json:"chat_id"`
	UploadedByID uuid.UUID  `json:"uploaded_by_id"`
	FileName     string     `json:"file_name"`
	FileType     string     `json:"file_type"`
	FileSize     int32      `json:"file_size"`
	FileLocation string     `json:"file_location"`
	FilePath     string     `json:"file_path"`
	UploadedAt   *time.Time `json:"uploaded_at"`
}

type MentorshipProfile struct {
	ID             uuid.UUID `json:"id"`
	UserID         uuid.UUID `json:"user_id"`
	DisplayName    string    `json:"display_name"`
	Avatar         string    `json:"avatar"`
	Title          string    `json:"title"`
	Description    string    `json:"description"`
	RatePerHour    float32   `json:"rate_per_hour"`
	AvailableTimes []byte    `json:"available_times"`
	IsPublished    bool      `json:"is_published"`
	Timezone       string    `json:"timezone"`
	CreatedAt      time.Time `json:"created_at"`
}

type Notification struct {
	ID         uuid.UUID   `json:"id"`
	SenderID   string      `json:"sender_id"`
	ReceiverID string      `json:"receiver_id"`
	Subject    pgtype.Text `json:"subject"`
	Content    string      `json:"content"`
	Method     Method      `json:"method"`
	Read       bool        `json:"read"`
	CreatedAt  *time.Time  `json:"created_at"`
}

type Payment struct {
	ID                    uuid.UUID         `json:"id"`
	UserID                uuid.UUID         `json:"user_id"`
	Amount                int32             `json:"amount"`
	Status                NullPaymentStatus `json:"status"`
	StripePaymentIntentID string            `json:"stripe_payment_intent_id"`
	StripeChargeID        pgtype.Text       `json:"stripe_charge_id"`
	Purpose               pgtype.Text       `json:"purpose"`
	CreatedAt             time.Time         `json:"created_at"`
	ReleaseDate           *time.Time        `json:"release_date"`
}

type Refund struct {
	ID             uuid.UUID        `json:"id"`
	PaymentID      uuid.UUID        `json:"payment_id"`
	TaskID         *uuid.UUID       `json:"task_id"`
	RefundReason   pgtype.Text      `json:"refund_reason"`
	RefundStatus   NullRefundStatus `json:"refundStatus"`
	ModeratorId    *uuid.UUID       `json:"moderatorId"`
	RefundedAt     *time.Time       `json:"refunded_at"`
	StripeRefundID pgtype.Text      `json:"stripe_refund_id"`
	CreatedAt      time.Time        `json:"created_at"`
	UpdatedAt      *time.Time       `json:"updated_at"`
}

type Session struct {
	ID        uuid.UUID   `json:"id"`
	UserID    uuid.UUID   `json:"user_id"`
	Token     string      `json:"token"`
	ExpiresAt time.Time   `json:"expires_at"`
	CreatedAt time.Time   `json:"created_at"`
	UpdatedAt time.Time   `json:"updated_at"`
	IpAddress pgtype.Text `json:"ip_address"`
	UserAgent pgtype.Text `json:"user_agent"`
}

type Solution struct {
	ID          uuid.UUID   `json:"id"`
	WorkspaceID uuid.UUID   `json:"workspace_id"`
	TaskID      uuid.UUID   `json:"task_id"`
	Content     []byte      `json:"content"`
	FileUrl     pgtype.Text `json:"file_url"`
	IsFinal     pgtype.Bool `json:"is_final"`
	CreatedAt   *time.Time  `json:"created_at"`
	UpdatedAt   *time.Time  `json:"updated_at"`
}

type SolutionFile struct {
	ID              uuid.UUID `json:"id"`
	SolutionID      uuid.UUID `json:"solution_id"`
	WorkspaceFileID uuid.UUID `json:"workspace_file_id"`
}

type SolutionWorkspace struct {
	ID          uuid.UUID `json:"id"`
	TaskID      uuid.UUID `json:"task_id"`
	SolverID    uuid.UUID `json:"solver_id"`
	Content     []byte    `json:"content"`
	ContentText string    `json:"contentText"`
	CreatedAt   time.Time `json:"created_at"`
}

type SolutionWorkspaceFile struct {
	ID           uuid.UUID      `json:"id"`
	WorkspaceID  uuid.UUID      `json:"workspace_id"`
	UploadedByID uuid.UUID      `json:"uploaded_by_id"`
	FileName     string         `json:"file_name"`
	FileType     string         `json:"file_type"`
	FileSize     int32          `json:"file_size"`
	FileLocation string         `json:"file_location"`
	FilePath     string         `json:"file_path"`
	IsDraft      pgtype.Bool    `json:"is_draft"`
	UploadedAt   time.Time      `json:"uploaded_at"`
	Status       NullFileStatus `json:"status"`
	UpdatedAt    time.Time      `json:"updated_at"`
}

type SolverProfile struct {
	UserID       uuid.UUID      `json:"user_id"`
	PortfolioUrl pgtype.Text    `json:"portfolio_url"`
	Skills       []string       `json:"skills"`
	AvgRating    pgtype.Numeric `json:"avg_rating"`
	TaskSolved   pgtype.Int4    `json:"task_solved"`
	CreatedAt    time.Time      `json:"created_at"`
	UpdatedAt    *time.Time     `json:"updated_at"`
}

type Subscription struct {
	ID                       uuid.UUID        `json:"id"`
	UserId                   uuid.UUID        `json:"userId"`
	StripeSubscriptionItemID pgtype.Text      `json:"stripe_subscription_item_id"`
	StripeSubscriptionID     pgtype.Text      `json:"stripe_subscription_id"`
	Tier                     Tier             `json:"tier"`
	CancelAt                 pgtype.Timestamp `json:"cancel_at"`
	IsCancelScheduled        bool             `json:"is_cancel_scheduled"`
	Status                   string           `json:"status"`
	Interval                 string           `json:"interval"`
	NextBilling              pgtype.Timestamp `json:"next_billing"`
	Price                    int32            `json:"price"`
	CreatedAt                time.Time        `json:"created_at"`
}

type Task struct {
	ID          uuid.UUID  `json:"id"`
	Title       string     `json:"title"`
	Description string     `json:"description"`
	Content     []byte     `json:"content"`
	Price       int32      `json:"price"`
	PosterID    uuid.UUID  `json:"poster_id"`
	SolverID    *uuid.UUID `json:"solver_id"`
	Visibility  Visibility `json:"visibility"`
	CategoryID  uuid.UUID  `json:"category_id"`
	PaymentID   uuid.UUID  `json:"payment_id"`
	Deadline    string     `json:"deadline"`
	CreatedAt   time.Time  `json:"created_at"`
	UpdatedAt   *time.Time `json:"updated_at"`
	TaskStatus  TaskStatus `json:"task_status"`
	AssignedAt  *time.Time `json:"assigned_at"`
}

type TaskCategory struct {
	ID        uuid.UUID        `json:"id"`
	Name      string           `json:"name"`
	CreatedAt pgtype.Timestamp `json:"created_at"`
}

type TaskComment struct {
	ID        uuid.UUID `json:"id"`
	TaskID    uuid.UUID `json:"task_id"`
	UserID    uuid.UUID `json:"user_id"`
	Content   string    `json:"content"`
	CreatedAt time.Time `json:"created_at"`
}

type TaskDeadline struct {
	ID        uuid.UUID `json:"id"`
	Deadline  string    `json:"deadline"`
	CreatedAt time.Time `json:"created_at"`
}

type TaskDraft struct {
	ID            uuid.UUID  `json:"id"`
	UserID        uuid.UUID  `json:"user_id"`
	Title         string     `json:"title"`
	Description   string     `json:"description"`
	Content       []byte     `json:"content"`
	ContentText   string     `json:"contentText"`
	Category      string     `json:"category"`
	Deadline      string     `json:"deadline"`
	UpdatedAt     time.Time  `json:"updated_at"`
	UploadedFiles []byte     `json:"uploadedFiles"`
	Visibility    Visibility `json:"visibility"`
	Price         int32      `json:"price"`
}

type TaskFile struct {
	ID           uuid.UUID  `json:"id"`
	TaskID       uuid.UUID  `json:"task_id"`
	FileName     string     `json:"file_name"`
	FileType     string     `json:"file_type"`
	FileSize     int32      `json:"file_size"`
	FileLocation string     `json:"file_location"`
	FilePath     string     `json:"file_path"`
	UploadedAt   *time.Time `json:"uploaded_at"`
}

type User struct {
	ID               uuid.UUID   `json:"id"`
	Name             string      `json:"name"`
	Email            string      `json:"email"`
	Password         pgtype.Text `json:"password"`
	Role             Role        `json:"role"`
	StripeCustomerID pgtype.Text `json:"stripe_customer_id"`
	StripeAccountID  pgtype.Text `json:"stripe_account_id"`
	EmailVerified    bool        `json:"emailVerified"`
	Image            pgtype.Text `json:"image"`
	CreatedAt        time.Time   `json:"created_at"`
	UpdatedAt        time.Time   `json:"updated_at"`
	Metadata         []byte      `json:"metadata"`
}

type UserDetail struct {
	UserID      uuid.UUID   `json:"user_id"`
	FirstName   pgtype.Text `json:"first_name"`
	LastName    pgtype.Text `json:"last_name"`
	DateOfBirth pgtype.Date `json:"date_of_birth"`
	Address     []byte      `json:"address"`
	Business    []byte      `json:"business"`
	UpdatedAt   *time.Time  `json:"updated_at"`
}

type Verification struct {
	ID         uuid.UUID `json:"id"`
	Identifier string    `json:"identifier"`
	Value      string    `json:"value"`
	ExpiresAt  time.Time `json:"expires_at"`
	CreatedAt  time.Time `json:"createdAt"`
	UpdatedAt  time.Time `json:"updatedAt"`
}
