// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addSolverToTaskBlockList = `-- name: AddSolverToTaskBlockList :one
INSERT INTO blocked_tasks (user_id, task_id, reason)
VALUES ($1, $2, $3) ON CONFLICT (user_id, task_id) DO NOTHING
RETURNING id, user_id, task_id, reason, created_at
`

type AddSolverToTaskBlockListParams struct {
	UserID pgtype.UUID
	TaskID pgtype.UUID
	Reason pgtype.Text
}

func (q *Queries) AddSolverToTaskBlockList(ctx context.Context, arg AddSolverToTaskBlockListParams) (BlockedTask, error) {
	row := q.db.QueryRow(ctx, addSolverToTaskBlockList, arg.UserID, arg.TaskID, arg.Reason)
	var i BlockedTask
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TaskID,
		&i.Reason,
		&i.CreatedAt,
	)
	return i, err
}

const getAIRules = `-- name: GetAIRules :many
SELECT rule
FROM ai_rules
`

func (q *Queries) GetAIRules(ctx context.Context) ([]string, error) {
	rows, err := q.db.Query(ctx, getAIRules)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var rule string
		if err := rows.Scan(&rule); err != nil {
			return nil, err
		}
		items = append(items, rule)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAvailbleTasks = `-- name: GetAvailbleTasks :many
SELECT id, title, description, content, price, poster_id, solver_id, visibility, category_id, payment_id, deadline, created_at, updated_at, task_status, assigned_at
FROM tasks
WHERE task_status = 'ASSIGNED'
  OR task_status = 'IN_PROGRESS'
  AND assigned_at IS NOT NULL
LIMIT $1
`

func (q *Queries) GetAvailbleTasks(ctx context.Context, limit int32) ([]Task, error) {
	rows, err := q.db.Query(ctx, getAvailbleTasks, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Task
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Content,
			&i.Price,
			&i.PosterID,
			&i.SolverID,
			&i.Visibility,
			&i.CategoryID,
			&i.PaymentID,
			&i.Deadline,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TaskStatus,
			&i.AssignedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTaskCategories = `-- name: GetTaskCategories :many
SELECT name
FROM task_categories
`

func (q *Queries) GetTaskCategories(ctx context.Context) ([]string, error) {
	rows, err := q.db.Query(ctx, getTaskCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var name string
		if err := rows.Scan(&name); err != nil {
			return nil, err
		}
		items = append(items, name)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsers = `-- name: GetUsers :many
SELECT id, name, email, password, role, stripe_customer_id, stripe_account_id, stripe_account_linked, "emailVerified", image, created_at
from users
`

func (q *Queries) GetUsers(ctx context.Context) ([]User, error) {
	rows, err := q.db.Query(ctx, getUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Email,
			&i.Password,
			&i.Role,
			&i.StripeCustomerID,
			&i.StripeAccountID,
			&i.StripeAccountLinked,
			&i.EmailVerified,
			&i.Image,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const processSystemNotification = `-- name: ProcessSystemNotification :one
INSERT INTO notifications (sender_id,receiver_id,subject,content,method,read)
VALUES ($1,$2,$3,$4,'SYSTEM',$5) RETURNING id, sender_id, receiver_id, subject, content, method, read, created_at
`

type ProcessSystemNotificationParams struct {
	SenderID   string
	ReceiverID string
	Subject    pgtype.Text
	Content    string
	Read       bool
}

func (q *Queries) ProcessSystemNotification(ctx context.Context, arg ProcessSystemNotificationParams) (Notification, error) {
	row := q.db.QueryRow(ctx, processSystemNotification,
		arg.SenderID,
		arg.ReceiverID,
		arg.Subject,
		arg.Content,
		arg.Read,
	)
	var i Notification
	err := row.Scan(
		&i.ID,
		&i.SenderID,
		&i.ReceiverID,
		&i.Subject,
		&i.Content,
		&i.Method,
		&i.Read,
		&i.CreatedAt,
	)
	return i, err
}

const resetTaskInfo = `-- name: ResetTaskInfo :exec
UPDATE tasks
SET 
    task_status = 'OPEN',
    assigned_at = NULL,
    updated_at = NOW(),
    solver_id = NULL
WHERE 
    id = $1
`

func (q *Queries) ResetTaskInfo(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, resetTaskInfo, id)
	return err
}
