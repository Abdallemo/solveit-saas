// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: chats.sql

package database

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const createChat = `-- name: CreateChat :one
INSERT INTO mentorship_chats (
seesion_id,
message,
sent_by,
sent_to,
pending
)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, seesion_id, message, sent_by, sent_to, read_at, pending, is_deleted, created_at
`

type CreateChatParams struct {
	SeesionID uuid.UUID `json:"seesion_id"`
	Message   *string   `json:"message"`
	SentBy    uuid.UUID `json:"sent_by"`
	SentTo    uuid.UUID `json:"sent_to"`
	Pending   *bool     `json:"pending"`
}

func (q *Queries) CreateChat(ctx context.Context, arg CreateChatParams) (MentorshipChat, error) {
	row := q.db.QueryRow(ctx, createChat,
		arg.SeesionID,
		arg.Message,
		arg.SentBy,
		arg.SentTo,
		arg.Pending,
	)
	var i MentorshipChat
	err := row.Scan(
		&i.ID,
		&i.SeesionID,
		&i.Message,
		&i.SentBy,
		&i.SentTo,
		&i.ReadAt,
		&i.Pending,
		&i.IsDeleted,
		&i.CreatedAt,
	)
	return i, err
}

const createChatFiles = `-- name: CreateChatFiles :exec
INSERT INTO mentorship_chat_files (
chat_id,
uploaded_by_id,
file_name,
file_type,
file_size,
file_path)
SELECT
  $1,
  $2,
  unnest($3::text[]),
  unnest($4::text[]),
  unnest($5::int[]),
  unnest($6::text[])
`

type CreateChatFilesParams struct {
	ChatID       uuid.UUID `json:"chat_id"`
	UploadedByID uuid.UUID `json:"uploaded_by_id"`
	FileName     []string  `json:"file_name"`
	FileType     []string  `json:"file_type"`
	FileSize     []int32   `json:"file_size"`
	FilePath     []string  `json:"file_path"`
}

func (q *Queries) CreateChatFiles(ctx context.Context, arg CreateChatFilesParams) error {
	_, err := q.db.Exec(ctx, createChatFiles,
		arg.ChatID,
		arg.UploadedByID,
		arg.FileName,
		arg.FileType,
		arg.FileSize,
		arg.FilePath,
	)
	return err
}

const deleteChatFileByPath = `-- name: DeleteChatFileByPath :exec
DELETE FROM mentorship_chat_files WHERE file_path = $1
`

func (q *Queries) DeleteChatFileByPath(ctx context.Context, filePath string) error {
	_, err := q.db.Exec(ctx, deleteChatFileByPath, filePath)
	return err
}

const deleteChatWithFiles = `-- name: DeleteChatWithFiles :one
WITH params AS (
    SELECT $1::uuid AS target_chat_id, $2::text AS target_file_path
),
deleted_file_action AS (
    UPDATE mentorship_chat_files
    SET is_deleted = true
    WHERE chat_id = (SELECT target_chat_id FROM params)
      AND file_path = (SELECT target_file_path FROM params)
    RETURNING file_path
),
remaining_files_check AS (
    SELECT COUNT(*) as count
    FROM mentorship_chat_files
    WHERE chat_id = (SELECT target_chat_id FROM params)
      AND is_deleted = false
      AND file_path != (SELECT target_file_path FROM params)
),
updated_chat_action AS (

    UPDATE mentorship_chats
    SET is_deleted = CASE
        WHEN (SELECT count FROM remaining_files_check) = 0
        THEN true
        ELSE is_deleted
    END
    WHERE id = (SELECT target_chat_id FROM params)
    RETURNING id, created_at, seesion_id, message, sent_by, sent_to, is_deleted
)

SELECT
    c.id,
    c.created_at,
    c.seesion_id,
    c.message,
    c.sent_by,
    c.sent_to,
    c.is_deleted,
    (
        SELECT COALESCE(array_agg(f.file_path), ARRAY[]::text[])
        FROM deleted_file_action f
    )::text[] AS deleted_file_paths
FROM updated_chat_action c
`

type DeleteChatWithFilesParams struct {
	ChatID   uuid.UUID `json:"chat_id"`
	FilePath string    `json:"file_path"`
}

type DeleteChatWithFilesRow struct {
	ID               uuid.UUID  `json:"id"`
	CreatedAt        *time.Time `json:"created_at"`
	SeesionID        uuid.UUID  `json:"seesion_id"`
	Message          *string    `json:"message"`
	SentBy           uuid.UUID  `json:"sent_by"`
	SentTo           uuid.UUID  `json:"sent_to"`
	IsDeleted        *bool      `json:"is_deleted"`
	DeletedFilePaths []string   `json:"deleted_file_paths"`
}

func (q *Queries) DeleteChatWithFiles(ctx context.Context, arg DeleteChatWithFilesParams) (DeleteChatWithFilesRow, error) {
	row := q.db.QueryRow(ctx, deleteChatWithFiles, arg.ChatID, arg.FilePath)
	var i DeleteChatWithFilesRow
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.SeesionID,
		&i.Message,
		&i.SentBy,
		&i.SentTo,
		&i.IsDeleted,
		&i.DeletedFilePaths,
	)
	return i, err
}

const getChatWithFilesByID = `-- name: GetChatWithFilesByID :one
SELECT
  c.id,
  c.created_at,
  c.seesion_id,
  c.message,
  c.sent_by,
  c.sent_to,
  c.read_at,
  c.pending,
  c.is_deleted,

  (
    json_build_object(
      'id', u.id,
      'name', u.name,
      'role', u.role,
      'image', u.image,
      'email', u.email
    )
  )::jsonb AS chat_owner,

  COALESCE(
    (
      SELECT jsonb_agg(
        jsonb_build_object(
          'id', f.id,
          'fileName', f.file_name,
          'fileType', f.file_type,
          'fileSize', f.file_size,
          'filePath', f.file_path,
          'uploadedAt', f.uploaded_at,
          'uploadedById', f.uploaded_by_id,
          'chatId', f.chat_id
        )
      )
      FROM mentorship_chat_files f
      WHERE f.chat_id = c.id
    ),
    '[]'::jsonb
  )::jsonb AS chat_files

FROM mentorship_chats c
JOIN users u ON u.id = c.sent_by
WHERE c.id = $1
ORDER BY c.created_at ASC
`

type GetChatWithFilesByIDRow struct {
	ID        uuid.UUID  `json:"id"`
	CreatedAt *time.Time `json:"created_at"`
	SeesionID uuid.UUID  `json:"seesion_id"`
	Message   *string    `json:"message"`
	SentBy    uuid.UUID  `json:"sent_by"`
	SentTo    uuid.UUID  `json:"sent_to"`
	ReadAt    *time.Time `json:"read_at"`
	Pending   *bool      `json:"pending"`
	IsDeleted *bool      `json:"is_deleted"`
	ChatOwner []byte     `json:"chat_owner"`
	ChatFiles []byte     `json:"chat_files"`
}

func (q *Queries) GetChatWithFilesByID(ctx context.Context, id uuid.UUID) (GetChatWithFilesByIDRow, error) {
	row := q.db.QueryRow(ctx, getChatWithFilesByID, id)
	var i GetChatWithFilesByIDRow
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.SeesionID,
		&i.Message,
		&i.SentBy,
		&i.SentTo,
		&i.ReadAt,
		&i.Pending,
		&i.IsDeleted,
		&i.ChatOwner,
		&i.ChatFiles,
	)
	return i, err
}
